[
  {
    "id": "01",
    "post": "# #01 What is React? How does it works?\n\n**#Video 01**\n\n# What is React? How does it work?\n\n## Why React?\n\nAccording to the official doc, “React” is a JS Library for building user interfaces (front-end). It handles user interactions on the web just like other front-end technologies but what makes it unique???\n\nSuppose we want to build a counter interface using typical HTML, CSS & a bit of JS. Grabbing HTML elements for counter placeholder, updating counter value, injecting incremented value in the placeholder — pretty straightforward , right??\n\nWhat happens when you want to build two counters at the same page?\n\nIt will require grabbing those HTML elements using unique selectors such as class/ids !!\n\nIf it’s a website like facebook and there are tons of counters such as Reaction Counters (Like, Love, Haha, Care, Angry etc), it would be a nightmare to select those elements using JS DOM operation and updating their states.\n\n### *React solves this problem mentioned above.*\n\n## Most fundamental operations by “React”\n\nLet’s include “React” into our html document by reading [official doc](https://reactjs.org/docs/add-react-to-a-website.html#add-react-in-one-minute). Then keep a div with id=”root”. This is the container of the “React Elements” to be rendered. Instead of document.createElement(), we will be using React.createElement() to create HTML elements in the “React” world.\n\nUsing theReact library, React creates its own (Virtual!) DOM elements. Then ReactDOM library renders /pushes those created (Virtual) DOM elements to the Real Browser DOM tree. Soon we will discuss React's Virtual DOM.\n\nWe can create elements by React’s trivial way of creating element by the React.createElement() function. But it’s quite a hassle. So, it’s convenient to use  JSX syntax to React element which is very similar to HTML, but has the super powers of JavaScript.\n\nJSX stands for Extensible JavaScript which is a combo of XML and JavaScript.\n\n## Summary\n\nReact says,\n\n*“If you manage states in React’s way, you don’t need to worry about DOM.”*\n\nIf react’s way is used to maintain states,then the elements made by React can be reused multiple times with their individual states maintained! Now think of that facebook example.\n\n*Never touch DOM while working with React.*"
  },
  {
    "id": "02",
    "post": "# #02 Virtual DOM\n\n# How does a typical DOM work?\n\nWhen the browser gets the HTML response along with the associated CSS file, it creates a DOM using HTML parser & CSSOM using CSS parser. Then DOM & CSSOM is combined in the \"Layout\" section which calculates the positions of the DOM & CSSOM combo tree as well as makes \"Render Tree\". Render Tree is printed on the display at the end. This process is quite fast.\n\nBut, when we do some DOM operations using JS, it will re-creates those DOM, CSSOM trees, calculate positioning coordinates, creates Render Tree and then render that newly created Render Tree. If there are tons of DOM operation required, this re-calculations will happen tons of time, which makes the UI slow. These multiple re-rendering is costly operations.\n\n“Batch update” comes to rescue ~ which means calculating, combining all states/state variables all together, then updating the UI/ re-render the DOM. The time complexity of rendering becomes 1. But without using “React”, this “Batch update” technique is not maintainable easily.\n\n# Virtual DOM\n\n*Replicated DOM which doesn’t require frequent repaint/re-render.*\n\nSince it is not convenient to re-render same elements even its state is not changed, it requires comparing before-after state variable values to check if the UI/element is required to change or not.\n\nReact does this by replicating the typical DOM tree. The replicated DOM is the Virtual DOM. If the state of any element changes, then React compares Virtual DOM & Browser DOM by a diffing algorithm “Reconciliation”. Calculates the changes in Virtual DOM by combining all the state changes together, then converts its Virtual DOM into Browser DOM and renders it. Instead of re-rendering DOM for each change of state, it renders the DOM once after the calculation of the change of the states.\n\nNormal JS DOM operations require grabbing html elements, detection of state change / listen to state change events, then changing the UI due to state change. React cuts the hassle into half by taking care of the UI change/ DOM rendering. We need to update the state/data of the UI and React take care of the rest.\n\n*Performance is not the main concern. Dev experience & Scalability matters.*"
  },
  {
    "id": "03",
    "post": "# #05 JSX Element & Rendering Elements\n\n## Documentations\n\nIntroduction to JSX [↗](https://reactjs.org/docs/introducing-jsx.html)\n\nRendering Elements [↗](https://reactjs.org/docs/rendering-elements.html)\n\n# The way Browser renders HTML\n\nRemember how vanilla JS manipulate DOM ? It creates new elements by **document.createElement(\"div\")** ,  then puts contents inside as necessary. Then it would update the browser DOM by appending the newly created NodeType element.\n\nVanilla JS directly manipulates the DOM, and it's capable of creating DOM Nodes/Elements.\n\n# The way React renders\n\nOn the other hand, REACT doesn't manipulate the Browser DOM directly. It compares the Replicated/Virtual DOM with the Browser DOM currently rendered, compares the state of these DOMs. If state/property changes, then React creates Necessary DOM Nodes/ React elements and replace the corresponding. First, React updates theVirtual DOM by calculating all possible state or property change altogether (**batch update**). Then renders theVirtual DOM as actual Browser DOM.\n\nUnlike Browser DOM Nodes/Elements, React Nodes or Elements are simple JS object which specifies how BrowserDOM will look llike after rendering. Creating Reat elements by using React.createElement() function is a big hassle. That's why **Babel** transpiler comes into play.\n\n# Babel\n\n**Babel** takes HTML/XML look-a-like syntax and converts them in React Elements which are just JS objects. Then ReactDOM constructs Browser DOM based on the JS object produced by transpiling those HTMLish syntax.\n\nBabel(HTMLish Syntax) ---> Plain JS Object ---> ReactElement(Plain JS Object) ---> ReactDOM/Virtual DOM\n\n> Don't use \" \" to wrap around JSX. Use (  ) instead. Since JSX are not plain text\n> \n\nJust like HTML element has attributes, React Elements also have attributes. Those can be accessed by the \"key\" props. React element is the smallest building block of React.\n\n# React & ReactDOM\n\nReact library only creates React Node/Element for the Virtual DOM tree.\nReactDOM library renders the Virtual DOM to the Main Browser DOM.\n\n# Immutable React Element\n\nA React Node/Element is IMMUTABLE. That means, React Node/Element can't be changed after constructing.If you need to change anything in React Node/Element, you need to do it before rendering or so. Reactre-calculates the React element if data/state/prop changes. It simply deletes the previous element and creates a new element if data/state/prop changes."
  },
  {
    "id": "04",
    "post": "# #06 Components and Props\n\n## Documentations\n\nComponents and Props [↗](https://reactjs.org/docs/components-and-props.html)\n\n# Component Concept\n\nReact element is the core building block of React app.\n\nBrowser parses HTML from server, and then typical Node/DOM tree. This 'browser made DOM Tree' is not valid JS object. It's something that browser understands. But React creates elements in plain JS object for its Virtual DOM.\n\nSince React element is immutable, it's pretty dumb. Once a React element created can't be changed. But React Component helps to change the React elements before they are created. Hence, React Component cant return React Elements based on the state/props provided.\n\n# Component Conventions\n\nReact components are either typical JS function or Class which returns/create React element. Those functions/classes can be called such as **`<MyComponent />`** . Different from calling a typical JS function or creating object instance using classes. But this **`<MyComponent />`** syntax allows to pass attributes just like HTML which is knows as props/state in React. **Make sure you name the Component Function/Class in Pascal case i.e MyComponent**.\n\n*App.js*\n\n```jsx\nimport React from \"react\";\n//import logo from \"./logo.svg\";\nimport \"./App.css\";\n\n//Importing our Component first\nimport MyComponent from './component/MyComponent';\n\nfunction App() {\n  return (\n    <div className=\"App\">\n\t\t      <MyComponent />\n    </div>\n  );\n}\n\nexport default App;\n```\n\nWhile passing attributes in <ComponentName/> such as \n\n`<MyComponent studentName={\"Faisal Rahman\"} />`\n\nthen the component can access those attribute value inside it's argument as a valid JS object. It's a good practice to destructure necessary propertis from the attribute/props object.\n\n*./component/MyComponent.js*\n\n```jsx\nimport React from 'react';\n\nclass MyComponent extends React.Component {\n\n\t//This render() method is mandatory\n\trender() {\n\n\t\t//Destructuring studentName from \n\t\t//Props that was sent from the App.js\n\t\tconst {studentName} = this.props; \n\t\t\n\t\treturn(\n\t\t\t<p> Student's Name: {studentName} </p>\n\t\t);\n\t}\n}\n\nexport default MyComponent;\n\t\t\t\n```\n\nTo have the super powers of React, hence, inherite React's built-in methods, it requires to extend React.Component while creating a Class based component. The props and states can be accessed inside the Class as this.state or this.props  respectively. **A class component should have a method named *render* which is provided by React.Component**. This render method is called by default for rendering the elements for first time or re-render the element if any state or prop changes.\n\n# State and Props Concept\n\nClass based components can listen to state change directly (doesn't require any extra help/function to listen to state/prop change). Since class is a blueprint of creating object, in this case, React Element, it can take necessary arguments as state/props, then creates React Elements.\n\n# Scope of State\n\nA component can maintain it's own states. As many as possible React Elements can be created using a React Component, and each instance of React Element will maintain its own state!!!. That's a beauty of React!"
  },
  {
    "id": "05",
    "post": "# #07 State & Lifecycle\n\n## Documentations\n\nState and Lifecycle [↗](https://reactjs.org/docs/state-and-lifecycle.html)\n\n# Component Types\n\nClass components are by default “Stateful” component and Functional components are by default “Stateless” components.  Then what is State in React? \n\n# State\n\nState is simply a set of data which may vary/change based on user interaction or so. Props is also some sort of state, but props are used to pass down state from a parent component to its children component if necessary. \n\nState is a self contained data-set/ set of variables inside a component. A single component may have the functionality of entire application, hence its own state. **A component re-renders if the state or props of it’s react element changes. Props are usually a way of communication between a Parent-Child components as  components can be nested.** \n\n# Handle State\n\nReact elements can’t be changed after construction, but we can change the states of the component and based on the state change, the element is re-rendered/re-created again.  This change of state can be done only by the methods provided by `React.Component` that we extend inside our component. \n\nThe state should be handled in *React’s Way* otherwise unpredictable things will happen. \n\nFirst we need to define the `constructor` function which constructs the parent class —> `React.Component`   ‘s props. Then inside the `constructor`, we can define the state variables only as a property of `this.state` objects property. `this.state` is inherited from the `React.Component` as we’ve extended it. \n\nIf we want to change the state, then we should use the `setState` method provided in `this` keyword. The code example below will put the handling state concept in  place.\n\n*./component/MyComponent.js*\n\n```jsx\n//import React from 'react';\n\n//Or you can directly\n//destructure 'Component'\n//from 'react'\nimport React, { Component } from 'react';\n\nclass MyComponent extends Component{\n\tconstructor(props){\n\t\t//Calling the Parent's constructor\n\t\t//via super(props)\n\t\tsuper(props);\n\n\t\t//Defining a state variable\n\t\tthis.state = {myState: 'Writing these Notes'}\n\t}\n\n\thandleClick = (e) => {\n\t\t\n\t\t//Changing state using setState function\n\t\t//If the paragraph element is clicked\n\t\tthis.setState({myState:\"Browsing the web\"});\n\t}\n\n\t//This render() method is mandatory\n\trender(){\n\t\tconst { myState } = this.state;\n\t\treturn(\n\t\t\t<p onClick={() => this.handleClick()} >\n\t\t\t\tI'm {myState} \n\t\t\t</p>\n\t\t);\n}\n\nexport default MyComponent;\n```\n\n# Lifecyle Methods\n\nClass based components have Lifecyle methods inherited from `React.Component` . These methods decides what to do when a component is rendering on screen, how a component should behave when a state or prop change, and destroy/non-function a component if someone hits another route or want to see other things on screen. \n\n`componentDidMount` , `componentShouldUpdate`  ,`componentWillUnmount` etc. are some common lifecycle methods of Class based component.  They are self explanatory according to their names."
  },
  {
    "id": "06",
    "post": "# #08 Handling Events & Controlling Re-Render\n\nTypically in HTML/Plain JavaScript, the onclick, onfocus etc event attribute takes a function’s reference which is a string refers to the function’s name. We don’t execute the function as we pass it as attribute value.\n\nIn React, the event attributes must in in camelCase, since the components are created using JSX. Then, it’s similar to Plain HTML/JS. It requires a function reference inside those curly braces { }, which is the variable that stores the method, usually `this.theMethod`. Don’t execute/call the function while passing it to the event attributes inside JSX. Remember the difference between **Passing Reference** Vs **Executing Function() .**\n\nReact Event handing methods can access the event object in the first parameter just like typical event handling function. Useful to prevent default, capturing event or so. \n\n*TimeStamp #Video 08 [14:41] **Important**. Climax at [17:00]*\n\nSuppose, we’ve implemented the example shown in the video. Now changing the component’s state variable (say count or so) by clicking a button. Hence, listening to a click event using a React Component method to change component’s state\n\nWhen the event handling method try to execute `this.setState( )`, it throws an error!! Because, Event Handling React Class Component Method is running in the **Browser’s DOM context**. It doesn’t have `this` inside the React Class Component’s  context.  The event handler must be executed in Browser’s context, not in Virtual DOM’s context, because the event will occur at the DOM that browser is currently rendering. \n\nSince the event handling method is called as a event handling callback function while rendering Browser/Real DOM, it requires to introduce the React Class Component’s `this` keyword to to the event handling callback function / method. This can be done in three ways.\n\n# 1. Using Function.prototype.bind() method\n\nAs we know, the bind() method takes an object as first parameter. The object that bind() method operates on/calls upon, make the  parameter object’s methods available to that object. And, it returns the method to call that method whenever convenient. You can pass the parameters for the function returned by bind() using  comma separated values, after the object is passed as first \nargument.  Or the returned function can be called by passing those arguments. \n\nYou can read the MDN doc here. [Function.prototype.bind() - JavaScript | MDN (mozilla.org)](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_objects/Function/bind)\n[Remember: bind() always returns a new instance of the method]\n\n``So, we can do `this.theEventHandlingMethod = this.theEventHandlingMethod.bind(this)` in the `constructor()` function of the Class component. \n\n# 2. Using Arrow function ⇒\n\nSince Arrow function doesn’t have it’s own `this` keyword. It simply runs in Browser’s Window context. `this` inside the arrow function, simply refers to the `window` object of the currently rendering DOM. (! May be wrong, research more) That’s why event handling function written using arrow function works like a charm in React. \n\n# Performance / Re-render Control\n\n*Timestamp #Video 08 [37:37] Performance / Re-render Control*\n\nFunctions / Methods can also be passed down to child components via props since Functions are simply First-Class objects in JS realm. \n\n*[ JSX should use `this` in props / .bind( ) ]*\n\nTo control Re-rendering, `shouldComponentUpdate` life-cycle method is used inside Class Component.\n\n*[ It requires precise implementation since wrong logic will prevent further re-rendering of child element. Specially keep in mind the **pass by reference** issue in JavaScript ]*\n\n`shouldComponentMount` should return `true` or `false` at the end. If `false` is returned, it won’t re-render the component. Since the video is using `bind( )`method to pass the function reference to the Button component, it’s not working because `bind( )` constructs new instance of the function. Even though, the props / arguments are not changing, but each instance of the function is a new reference. That’s why equality checking ( === ) is returning `false` since their references are different. *[ This is why ESLint doesn’t recommend using `bind( )` in JSX ]*\n\n# Best Practices\n\n1. Use Arrow function ⇒ for event handling methods.\n2. Don’t send parameters along with functions reference, send those parameters via props.\n3. Don’t use `shouldComponentUpdate` frequently. 😅 Logically preventing unnecessary re-render of a large component is convenient. Re-rendering small components is not an issue. \n\nReact solves development issues at some costs of performance. But it’s worth it. Building a large scale application requires a clean way of development. Performance can be optimized later. Obsession with performance for trimming few milliseconds is obsolete."
  }
]
